#!/bin/zsh

export WORKON_HOME=~/venv
export PROJECT_HOME=~/devel
export VIRTUAL_ENV_DISABLE_PROMPT=1

# where to look for virtualenvwrapper
for candidate in /usr/bin /usr/local/bin; do
    if [[ -e $candidate/virtualenvwrapper.sh ]]; then
	source $candidate/virtualenvwrapper.sh
	break
    fi
done

newvirtualenv() {
    if [[ -z $1 ]]; then
        base=$(pwd)
    else
        base=$1
    fi
    name=$(basename $base)
    args="-a $base"
    if [[ -e $base/requirements.txt ]]; then
        args="$args -r $base/requirements.txt"
    elif [[ -e $base/requirements.pip ]]; then
        args="$args -r $base/requirements.pip"
    fi

    mkvirtualenv ${=args} --system-site-packages $name
}

get_venv_prompt_info() {
    if [[ -n $VIRTUAL_ENV ]]; then
        echo "$(basename $VIRTUAL_ENV):"
    fi
}

# determine if which supports --skip-alias
if which --skip-alias which >& /dev/null; then
    alias _find_executable='which --skip-alias --skip-functions'
else
    _find_executable() {
        which -a $1 | sed -n '/^\//p' | head -n 1
    }
fi

# make various python utilities virtualenv-aware so we don't have to
# install them in every virtualenv
__virtualenv_python_alias() {
    alias $1='$(_find_executable python)'" $(_find_executable $1)"
}

__virtualenv_python_alias bpython
__virtualenv_python_alias ipython
