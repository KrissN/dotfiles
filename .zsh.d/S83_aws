#!/bin/zsh

_zshrc_log "Loading AWS toolsets"

# Explicitly list AWS CLI toolsets that don't have README files, or
# for which the necessary environment variable cannot be determined
# from the README.  Keys are toolset names, values are _HOME variable
# names
typeset -A _AWS_TOOLSETS
_AWS_TOOLSETS=(ec2-api-tools EC2)

AWS_HOME=$(readlink -f ~/bin/aws)

if [[ -e "$AWS_HOME" ]]; then
    for tooldir in $(find "$AWS_HOME" -mindepth 1 -maxdepth 1 -type d); do
        toolname=$(basename $tooldir | sed 's/-[.[:digit:]]*$//')
        readme=$(find "$tooldir" -maxdepth 1 -iname readme\*)
        if [[ -n $_AWS_TOOLSETS[$toolname] ]]; then
            var=$_AWS_TOOLSETS[$toolname]
            _zshrc_log "$toolname: Using variable name from _AWS_TOOLSETS"
        elif [[ -n $readme ]]; then
            var=$(grep -o 'AWS_[A-Z_]*_HOME' "$readme" | head -n 1)
            _zshrc_log "$toolname: Determined variable name from $readme"
        else
            echo "No README found in $tooldir"
        fi
        if [[ -n $var ]]; then
            _zshrc_log "Registering AWS toolset $toolname with $var"
            eval "export $var='$tooldir'"
            pathmunge $tooldir/bin after
        else
            echo "Could not determine environment variable for $toolname"
        fi
    done

    if [[ -z $JAVA_HOME ]]; then
        export JAVA_HOME=$(dirname $(which java))/..
    fi
fi

cfn-watch-stack-events() {
    if [[ -z $1 ]]; then
        echo "Usage: $0 <stack name>"
        return 1
    fi

    new=
    output=$(cfn-describe-stack-events --stack-name=$1 | tac)
    echo $output
    sleep 2

    while true; do
        new=$(cfn-describe-stack-events --stack-name=dev-webapp-elb-test | tac)
        echo $new | diff - <(echo $output) | sed -n '/^< / { s/^< //; p; }'
        output="$new"
        sleep 2
    done
}

_get_aws_envs() {
    find "$AWS_HOME" -maxdepth 1 -type f -name credentials.\* -printf '%f\n' |\
        sed 's/^credentials\.//'
}

_get_aws_default_env() {
    if [[ -L "$AWS_HOME"/credentials.default ]]; then
        readlink -f "$AWS_HOME"/credentials.default | sed 's/.*credentials\.//'
    fi
}

aws_env() {
    if [[ -z $1 ]]; then
        echo "Available AWS environments:"
        _get_aws_envs | \
            sed "s/^\(.*\)$/  \1/;
                 s/^  \($__AWS_ENV\)$/* \1/;
                 s/^\(..$(_get_aws_default_env)\)\$/\1 (default)/"
    elif [[ -e "$AWS_HOME/credentials.$1" ]]; then
        export AWS_CREDENTIAL_FILE="$AWS_HOME/credentials.$1"
        export AWS_ACCESS_KEY=$(awk -F= '/AWSAccessKeyId/ {print $NF}' \
            $AWS_CREDENTIAL_FILE)
        export AWS_SECRET_KEY=$(awk -F= '/AWSSecretKey/ {print $NF}' \
            $AWS_CREDENTIAL_FILE)
        export __AWS_ENV="$1"
    else
        echo "AWS environment $1 not found"
        aws_env
    fi
}

if [[ -n _get_aws_default_env ]]; then
    aws_env "$(_get_aws_default_env)"
fi
