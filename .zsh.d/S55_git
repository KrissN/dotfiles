#!/bin/zsh

export __CURRENT_GIT_REPO=
export __CURRENT_GIT_BRANCH=

parse_git_repo() {
    export __CURRENT_GIT_REPO="$(git remote -v 2> /dev/null | \
        awk '/\(fetch\)$/ { split($2,a,"/"); sub(/\.git$/, "", a[length(a)]); print a[length(a)]; }' | \
        sort | uniq -c | sort -n | tail -n 1 | awk '{print $NF}')"
    if [[ $__CURRENT_GIT_REPO != "dotfiles" ]]; then
        export __CURRENT_GIT_BRANCH="$(git branch --no-color 2> /dev/null | \
            sed -e '/^[^*]/d; s/^* //;')"
    else
        export __CURRENT_GIT_BRANCH=
    fi
}

zsh_update_git_vars() {
    case "$1" in
        *git*)
            parse_git_repo
            ;;
    esac
}

get_git_prompt_info() {
    if [[ -n $__CURRENT_GIT_REPO && -n $__CURRENT_GIT_BRANCH ]]; then
        echo " (${__CURRENT_GIT_REPO}:${__CURRENT_GIT_BRANCH})"
    fi
}

git_topdir() {
    # this function finds the top-level directory for the current git
    # working copy

    # first, let's find the origin URL and hope that perhaps, just
    # perhaps, this WC was checked out into a directory named after
    # the repo (i.e., the default behavior)
    rname="$(git config --get remote.origin.url | \
             awk -F/ '{ sub(/\.git$/, "", $NF); print $NF; }')"
    basepath=""
    for dir in $(pwd -P | sed 's/^\///; s/\// /g'); do
        basepath="$basepath/$dir"
        if [[ "$dir" == "$rname" && -e "$basepath/.git" ]]; then
            echo $basepath
            return 0
        fi
    done

    # if that didn't work, work through the parent directories and see
    # which one has a .git in it.  if we're inside a submodule, this
    # obviously won't work -- at least, not for some value of "work."
    # you could say that it works perfectly
    cwd=$(pwd -P)

    while [[ -n "$cwd" ]]; do
        if [[ -e "$cwd/.git" ]]; then
            echo $cwd
            return 0
        fi
        cwd=$(echo $cwd | sed 's/\(.*\)\/[^/\]*/\1/')
    done
    
    return 1
}

git_submodule_update() {
    pushd $(git_topdir)
    git submodule update
    popd
}

if type git >& /dev/null; then
    if [[ -z $__git_bin ]]; then
        if [[ $(type git) == "git is a shell function" ]]; then
            unfunction git
        fi
        __git_bin=$(which git)
    fi

    # we run parse_git_repo and parse_git_branch on three occasions:
    #
    # 1.  When this file is first loaded;
    # 2.  When a git command is run; and
    # 3.  When cd is run
    parse_git_repo
    preexec_functions[$(($#preexec_functions + 1))]='zsh_update_git_vars'
    chpwd_functions[$(($#chpwd_functions + 1))]='parse_git_repo'

    git() {
        cmd=$1
        if [[ -n $cmd && ($cmd == "co" || $cmd == "checkout") ]]; then
            $__git_bin $*
            rv=$?
            git_submodule_update
            return $rv
        else
            $__git_bin $*
        fi
    }
fi
